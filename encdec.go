package base64

import (
	"errors"
)

const cs = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

func Encode(dst, src []byte) {
	srcLen := len(src) - 2
	i, j := 0, 0
	for i < srcLen {
		dst[j] = cs[src[i]>>2]
		srcI1 := uint64(src[i+1]) << 8
		dst[j+1] = cs[(uint64(src[i])<<16|srcI1)<<46>>58]
		srcI2 := uint64(src[i+2])
		dst[j+2] = cs[(srcI1|srcI2)<<52>>58]
		dst[j+3] = cs[(srcI2 & 0b111111)]
		i += 3
		j += 4
	}
	switch srcLen - i {
	case 0:
		dst[j] = cs[src[i]>>2]
		dst[j+1] = cs[(uint64(src[i])<<8|uint64(src[i+1]))<<54>>58]
		dst[j+2] = cs[src[i+1]<<4>>2]
		dst[j+3] = '='
	case -1:
		dst[j] = cs[src[i]>>2]
		dst[j+1] = cs[src[i]<<6>>2]
		dst[j+2] = '='
		dst[j+3] = '='
	}
}

var z = [256]uint64{
	64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
	64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
	64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 62, 64, 64, 64, 63,
	52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 64, 64, 64, 0, 64, 64,
	64, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
	15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 64, 64, 64, 64, 64,
	64, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
	41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 64, 64, 64, 64, 64,
	64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
	64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
	64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
	64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
	64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
	64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
	64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
	64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
}

func Decode(dst, src []byte) (j int, err error) {
	/*
		z := [256]uint64{
			'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4, 'F': 5, 'G': 6, 'H': 7,
			'I': 8, 'J': 9, 'K': 10, 'L': 11, 'M': 12, 'N': 13, 'O': 14, 'P': 15,
			'Q': 16, 'R': 17, 'S': 18, 'T': 19, 'U': 20, 'V': 21, 'W': 22, 'X': 23,
			'Y': 24, 'Z': 25, 'a': 26, 'b': 27, 'c': 28, 'd': 29, 'e': 30, 'f': 31,
			'g': 32, 'h': 33, 'i': 34, 'j': 35, 'k': 36, 'l': 37, 'm': 38, 'n': 39,
			'o': 40, 'p': 41, 'q': 42, 'r': 43, 's': 44, 't': 45, 'u': 46, 'v': 47,
			'w': 48, 'x': 49, 'y': 50, 'z': 51, '0': 52, '1': 53, '2': 54, '3': 55,
			'4': 56, '5': 57, '6': 58, '7': 59, '8': 60, '9': 61, '+': 62, '/': 63,
		}
		for i := range 256 {
			if z[i] == 0 {
				z[i] = 64
			}
		}
		z['='] = 0
		z['A'] = 0
		z, _ := json.Marshal(z)
		println(string(z))
	*/
	i := 0
	var v uint64
	l := len(dst) - 3
	for j < l {
		x0, x1, x2, x3 := z[src[i]], z[src[i+1]], z[src[i+2]], z[src[i+3]]
		if x0&x1&x2&x3 > 63 {
			err = errors.New("invalid base-64")
			return
		}
		i += 4
		v = ((x0<<6|x1)<<6|x2)<<6 | x3
		dst[j] = byte(v >> 16)
		dst[j+1] = byte(v >> 8)
		dst[j+2] = byte(v)
		j += 3
	}
	x0, x1, x2, x3 := z[src[i]], z[src[i+1]], z[src[i+2]], z[src[i+3]]
	if x0&x1&x2&x3 > 63 {
		err = errors.New("invalid base-64")
		return
	}
	v = ((x0<<6|x1)<<6|x2)<<6 | x3
	dst[j] = byte(v >> 16)
	switch j - l {
	case 0:
		dst[j+1] = byte(v >> 8)
		dst[j+2] = byte(v)
		j += 3
	case 1:
		dst[j+1] = byte(v >> 8)
		j += 2
	case 2:
		j++
	}
	return
}

//10011100100110100000000
